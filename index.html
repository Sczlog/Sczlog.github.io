<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Sczlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Sczlog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sczlog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sczlog">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Sczlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Sczlog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-leetcode 2020-11-05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/06/leetcode%202020-11-05/" class="article-date">
  <time datetime="2020-11-06T05:21:33.000Z" itemprop="datePublished">2020-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/06/leetcode%202020-11-05/">LeetCode笔记 2020年11月5日</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="英文站："><a href="#英文站：" class="headerlink" title="英文站："></a>英文站：</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-height-trees/">310. Minimum Height Trees</a></p>
<h3 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h3><p>A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.</p>
<p>Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).</p>
<p>Return a list of all MHTs’ root labels. You can return the answer in any order.</p>
<p>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>
<p><strong>constraints:</strong></p>
<ul>
<li>1 &lt;= n &lt;= 2 * 104</li>
<li>edges.length == n - 1</li>
<li>0 &lt;= ai, bi &lt; n</li>
<li>ai != bi</li>
<li>All the pairs (ai, bi) are distinct.</li>
<li>The given input is guaranteed to be a tree and there will be no repeated edges.</li>
</ul>
<h2 id="1-广度优先搜索BFS"><a href="#1-广度优先搜索BFS" class="headerlink" title="1. 广度优先搜索BFS"></a>1. 广度优先搜索BFS</h2><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这里所要找的最小高度树，其实是希望找到特定结点，以此节点为根，到所有结点的深度的最大值最短。<br>所以我就希望通过制作图的同时更新连通情况，这里就能得到每个点的最大深度，最后做一次对比。<br>然后就TLE了，这个解法实际上是正确的，但是复杂度较高，用JS提交的时候甚至heap内存溢出了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">FindMinHeightTrees</span>(<span class="params"><span class="built_in">int</span> n, <span class="built_in">int</span>[][] edges</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IList&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="built_in">int</span>[] maxsHeight = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">    <span class="built_in">int</span>[][] graph = <span class="keyword">new</span> <span class="built_in">int</span>[n][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; graph.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line">        maxsHeight[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; graph.Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            graph[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> edge <span class="keyword">in</span> edges)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">int</span> b = edge[<span class="number">1</span>];</span><br><span class="line">        graph[a][b] = graph[b][a] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == a || i == b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (graph[a][i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> newDis = graph[a][i] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (graph[i][b] == <span class="number">0</span> || graph[i][b] &gt; newDis)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxsHeight[i] &lt; newDis)</span><br><span class="line">                    &#123;</span><br><span class="line">                        maxsHeight[i] = newDis;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (maxsHeight[b] &lt; newDis)</span><br><span class="line">                    &#123;</span><br><span class="line">                        maxsHeight[b] = newDis;</span><br><span class="line">                    &#125;</span><br><span class="line">                    graph[i][b] = graph[b][i] = newDis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (graph[b][i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> newDis = graph[b][i] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (graph[i][a] == <span class="number">0</span> || graph[i][a] &gt; newDis)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxsHeight[i] &lt; newDis)</span><br><span class="line">                    &#123;</span><br><span class="line">                        maxsHeight[i] = newDis;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (maxsHeight[a] &lt; newDis)</span><br><span class="line">                    &#123;</span><br><span class="line">                        maxsHeight[a] = newDis;</span><br><span class="line">                    &#125;</span><br><span class="line">                    graph[a][i] = graph[i][a] = newDis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> min = <span class="built_in">int</span>.MaxValue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; maxsHeight.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> height = maxsHeight[i];</span><br><span class="line">        <span class="keyword">if</span> (min &lt; height)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != height)</span><br><span class="line">        &#123;</span><br><span class="line">            list.Clear();</span><br><span class="line">            min = height;</span><br><span class="line">        &#125;</span><br><span class="line">        list.Add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>空间：O(N^2) 由边做成图需要有N^2的二维数组来存储图的连通情况, 另外额外需要一个O(N)的数组来记录最小深度的下标。<br>时间：O(N^2) 计算边长在制图的时候就完成了，是一个O(N^2)的操作，而比较最大深度则需要O(N^2)的时间，优化后比较需要O(N)，故综合为O(N^2)。</p>
<h2 id="2-BFS变种"><a href="#2-BFS变种" class="headerlink" title="2. BFS变种"></a>2. BFS变种</h2><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>从另外一个角度出发，什么样的结点会是符合要求的结点，从结构上来说越处于中间位置的点才越有可能是所需的根节点，那么相比于选点，我们可以删点，删除最外层的点，直到留下一个点或者留下一条边。</p>
<p>这个算法能够成功的原理在于树是有向无环的，相当于实现了一个拓扑排序，只不过我们在没确定根节点前是无法判断方法的。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMinHeightTrees = <span class="function"><span class="keyword">function</span>(<span class="params">n, edges</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> degrees = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (edges.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> edge = edges[i]</span><br><span class="line">            degrees[edge[<span class="number">0</span>]]++;</span><br><span class="line">            degrees[edge[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> tmpedges = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> edge = edges[i]</span><br><span class="line">            <span class="keyword">if</span> (degrees[edge[<span class="number">0</span>]] &gt; <span class="number">1</span> &amp;&amp; degrees[edge[<span class="number">1</span>]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                tmpedges.push(edge);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (degrees[edge[<span class="number">0</span>]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                root = edge[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (degrees[edge[<span class="number">1</span>]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                root = edge[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        degrees.fill(<span class="number">0</span>);</span><br><span class="line">        edges = tmpedges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> edges.length ? edges[<span class="number">0</span>] : [root];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>空间：O(N)，额外的存储结点的度，以及一个临时的边数组。<br>时间：O(N^2)，最差情况下树是一个类似于0-&gt;1-&gt;2-&gt;3-&gt;4这种类链表结构，取得是中点，这种情况下每次删点只能删两个，这个情况是O(N^2)，最好情况是一个类似烟花的结构，是O(N)，平均是O(N^2)，但是大部分情况下删除节点的速度很快，所以在没有改变基数的情况下可以通过。 <br>优化后可以实现O(N)，即只需要使用边构建一次图的度后，后续都是通过结点来更新度而不是使用边，具体解法可以见连接。</p>
<hr>
<h2 id="中文站："><a href="#中文站：" class="headerlink" title="中文站："></a>中文站：</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></p>
<h3 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h3><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
</ul>
<p>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p>
<h2 id="1-单向BFS"><a href="#1-单向BFS" class="headerlink" title="1. 单向BFS"></a>1. 单向BFS</h2><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><p>对于起点而言，在wordList中遍历所有它可以访问且没有被访问过的点。<br>（因为是BFS，访问过的点所代表的深度肯定比第二次访问得到的深度要少）<br>如果没有可以访问的点，说明起点终点不相邻，返回0。<br>如果找到了可以访问的点：</p>
<ol>
<li>是终点：返回路径长度；</li>
<li>不是终点，将这些点表示为访问过的点，并作为下一次遍历的起点，并等待下次遍历。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ladderLength = <span class="function">(<span class="params">beginWord, endWord, wordList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!~wordList.indexOf(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> visited = &#123;</span><br><span class="line">            beginWord: <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> query = [beginWord];</span><br><span class="line">        <span class="keyword">while</span> (query.length) &#123;</span><br><span class="line">            <span class="keyword">let</span> _query = [];</span><br><span class="line">            d++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">of</span> query) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> wordList) &#123;</span><br><span class="line">                    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length &amp;&amp; count &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (word[i] !== index[i]) count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (count === <span class="number">1</span> &amp;&amp; !visited[word]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (word === endWord) &#123;</span><br><span class="line">                            <span class="keyword">return</span> d;</span><br><span class="line">                        &#125;</span><br><span class="line">                        visited[word] = <span class="number">1</span>;</span><br><span class="line">                        _query.push(word);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                query = _query;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>空间：O(N)，额外的存储当前结点的数组：O(N)，存储访问过的结点的hashMap：O(N)<br>时间：O(N*C)，C为字符串长度，用来判断字符差需要O(C)，最多有N/2次比较（访问过的点不会需要比较）。</p>
<p>PS：代码里面用的visited判断其实没写好，跑起来应该是O(N^2*C)，应该是visited过的是不需要进到比较的，但是从提交上来看，如果我加了 <code>if(visited[word])&#123;continue;&#125;</code> 的话反而会变慢，不太清楚原因，hashMap取值应该是O(1)的操作。</p>
<h2 id="2-虚拟节点BFS"><a href="#2-虚拟节点BFS" class="headerlink" title="2. 虚拟节点BFS"></a>2. 虚拟节点BFS</h2><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>待更</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ladderLength = <span class="function"><span class="keyword">function</span>(<span class="params">beginWord, endWord, wordList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> h = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> query = [beginWord];</span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> word <span class="keyword">of</span> wordList) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, t; i &lt; word.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> tmp = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>);</span><br><span class="line">            h[tmp] ? h[tmp].push(word) : h[tmp] = [word]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (query.length &amp;&amp; ++d) &#123;</span><br><span class="line">        <span class="keyword">var</span> length = query.length</span><br><span class="line">        <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = query.shift()) === endWord) &#123;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, t; i &lt; n.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t = h[n.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + n.substring(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> word <span class="keyword">of</span> t) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!r.has(word)) &#123;</span><br><span class="line">                            query.push(word);</span><br><span class="line">                            r.add(word);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><p>空间：O(N*C^2)，额外的虚拟结点，一共N*C个长度为C的虚拟节点 <br>时间：O(N*C^2)，广度优先的最坏情况。</p>
<h2 id="3-双向BFS"><a href="#3-双向BFS" class="headerlink" title="3. 双向BFS"></a>3. 双向BFS</h2><p>上面一种的优化版本，待更。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/06/leetcode%202020-11-05/" data-id="ckh629r9c00003obhaib09kdw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="tag">每日一题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode 2020-11-06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/06/leetcode%202020-11-06/" class="article-date">
  <time datetime="2020-11-06T02:52:50.000Z" itemprop="datePublished">2020-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/06/leetcode%202020-11-06/">LeetCode笔记 2020年11月6日</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>没啥东西写的时候就更下LeetCode的每日一题。<br>中文站的和英文站的每天都做一下还挺有意思的。</p>
<h2 id="英文站："><a href="#英文站：" class="headerlink" title="英文站："></a>英文站：</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/">1217. Minimum Cost to Move Chips to The Same Position</a></p>
<h3 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h3><p>We have <code>n</code> chips, where the position of the <code>ith</code> chip is <code>position[i]</code> . <br>We need to move all the chips to the same position. In one step, we can change the position of the <code>ith</code> chip from <code>position[i]</code> to:<br><code>position[i] + 2</code> or <code>position[i] - 2</code> with <code>cost = 0</code> .<br><code>position[i] + 1</code> or <code>position[i] - 1</code> with <code>cost = 1.</code> <br>Return the minimum cost needed to move all the chips to the same position.</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>乍一看很唬人的题，因为一股用DP求最优解又看不大出状态转移方程的样子，这种题一般都是hard级的。<br>仔细一分析才发现其实是个绣花枕头，本质上是一个简单的贪心算法，做完一看原题，果不其然easy题。<br>这里最关键一点是，移动钱币到间隔为1的位置的消耗为0，那么我们可以简单的把奇数位置的硬币放到一起，把偶数位置的硬币堆到与之相邻的位置，最后做一次统一的汇总即可，即简化为数出奇数位和偶数位的硬币总数，然后去两者较小值。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">position</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minCostToMoveChips = <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> even = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> length = position.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (position[i] % <span class="number">2</span>) &#123;</span><br><span class="line">            odd++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            even++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> odd &gt; even ? even : odd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>空间：没有额外的开销，常数级的两个count，O(1)。<br>时间：遍历一遍数组，O(N)。</p>
<h2 id="中文站："><a href="#中文站：" class="headerlink" title="中文站："></a>中文站：</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">1356. 根据数字二进制下 1 的数目排序</a></p>
<h3 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。<br>如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。<br>请你返回排序后的数组。</p>
<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>相比于英文站看上去很强，这个看上去就很弱，实现一个comparator即可</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortByBits = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> getBinary = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> radix = num % <span class="number">2</span>;</span><br><span class="line">            num = (num - radix) / <span class="number">2</span>;</span><br><span class="line">            result += radix;</span><br><span class="line">        &#125; <span class="keyword">while</span> (num !== <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="params">e</span> =&gt;</span> [getBinary(e), e]).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] !== b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).map(<span class="function"><span class="params">e</span> =&gt;</span> e[<span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>空间：map操作创造了一个额外的数组，O(N)。<br>时间：使用了内置的快排，O(N*LOGN)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/06/leetcode%202020-11-06/" data-id="ckh629r9x00053obhdsw8hogd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="tag">每日一题</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="tag">每日一题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/LeetCode/" style="font-size: 10px;">LeetCode</a> <a href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" style="font-size: 10px;">每日一题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/06/leetcode%202020-11-05/">LeetCode笔记 2020年11月5日</a>
          </li>
        
          <li>
            <a href="/2020/11/06/leetcode%202020-11-06/">LeetCode笔记 2020年11月6日</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Sczlog<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>